(* ::Package:: *)

(* ::Input:: *)
(*(* :Title:Yahtzee*)*)
(*(* :Context:Yahtzee`*)*)
(*(* :Author:Un Nome*)*)
(*(* :Summary:Questo programma permette a un utente singolo di giocare a Yahtzee*)*)
(*(* :Copyright: Simone Branchetti, Alex Citeroni, Mirko Scozia, Davide Talevi, Yana Dolganiuk*)*)
(*(* :Package Version:1*)*)
(*(* :Mathematica Version:13*)*)
(*(* :History:Versions 15,May a.a 2021/2022*)*)
(*(* :Keywords:yahtzee,dice,game*)*)
(*(* :Sources:wolfram, cardgames-yahtzee*)*)
(**)
(*BeginPackage["Yahtzee`"]*)
(**)
(*(*usages*)*)
(*YAHTZEE::usage="YAHTZEE fa incominciare una partita a giocatore singolo di Yahtzee."*)
(**)
(*Begin["Private`"]*)
(**)
(*(* Definiamo il costruttore del gioco definendo tutti i sui moduli logici e grafici*)*)
(*YAHTZEE:=DynamicModule[{rollButton,girato,dice1Lock,dice2Lock,dice3Lock,dice4Lock,dice5Lock,dice1,dice2,dice3,dice4,dice5,listK,acesK,aces,twosK,twos,threesK,threes,foursK,fours,fivesK,fives,sixesK,sixes,threeOfAKindK,threeOfAKind,fourOfAKindK,fourOfAKind,fullHouseK,fullHouse,smallStraightK,smallStraight,largeStraightK,largeStraight,yahtzeeK,yahtzee,chanceK,chance,bonus,d1,d2,d3,d4,d5,oneDice,twoDice,threeDice,fourDice,fiveDice,color1,color2,color3,color4,color5,tabella,cleanCellsButton,clean,restartButton,highButton,rulesButton,saveButton,closeButton,flagSave ,dices,listPoints,listPointSup,listPointInf,listCombinations,flagPunteggioSelezionato,reset ,imgDice1,imgDice2,imgDice3,imgDice4,imgDice5,imgDice6},*)
(**)
(*SeedRandom[seme];*)
(**)
(*(*importiamo le immagini per le facce dei dadi*)*)
(*imgDice1:=Import[FileNameJoin[{NotebookDirectory[],"img","1_hd.png"}],ImageSize->35];*)
(*imgDice2:=Import[FileNameJoin[{NotebookDirectory[],"img","2_hd.png"}],ImageSize->35];*)
(*imgDice3:=Import[FileNameJoin[{NotebookDirectory[],"img","3_hd.png"}],ImageSize->35];*)
(*imgDice4:=Import[FileNameJoin[{NotebookDirectory[],"img","4_hd.png"}],ImageSize->35];*)
(*imgDice5:=Import[FileNameJoin[{NotebookDirectory[],"img","5_hd.png"}],ImageSize->35];*)
(*imgDice6:=Import[FileNameJoin[{NotebookDirectory[],"img","6_hd.png"}],ImageSize->35];*)
(**)
(*(* Definiamo la lista dei dadi *)*)
(*dices:={dice1,dice2,dice3,dice4,dice5};*)
(**)
(*(* Instanziamo le liste delle varie combinazioni: quella completa e due per la sezione superiore e inferiore del tabellone. Quella superiore in particolare serve per assegnare i punti bonus*)*)
(*listPoints:={aces,twos,threes,fours,fives,sixes,bonus,threeOfAKind,fourOfAKind,fullHouse,smallStraight,largeStraight,yahtzee,chance};*)
(*listPointSup:= {aces,twos,threes,fours,fives,sixes};*)
(*listPointInf := {threeOfAKind,fourOfAKind,fullHouse,smallStraight,largeStraight,yahtzee,chance};*)
(**)
(*(*Queste due flag servono per selezionare solo una combinazione ogni turno e salvare un punteggio una volta e basta a fine partita rispettivamente.*)*)
(*flagPunteggioSelezionato=False;*)
(*flagSave = True;*)
(**)
(*(*colore dei dadi al lancio, usate per la logica del blocco dei valori red/green*)*)
(*color1=Green;color2=Green;color3=Green;color4=Green;color5=Green;*)
(**)
(*(*usiamo delle variabili string per mostrare se il dado sia bloccato o meno*)*)
(*d1="Libero";d2="Libero";d3="Libero";d4="Libero";d5="Libero";*)
(**)
(*(*definaimo le variabili per bloccare il punteggio effettuato ad ogni turno cosi da rendere uniche le combinazioni e tenere traccia dei punteggi.*)*)
(*acesK=False;aces=0;*)
(*twosK=False;twos=0;*)
(*threesK=False;threes=0;*)
(*foursK=False;fours=0;*)
(*fivesK=False;fives=0;*)
(*sixesK=False;sixes=0;*)
(*threeOfAKindK=False;threeOfAKind=0;*)
(*fourOfAKindK=False;fourOfAKind=0;*)
(*fullHouseK=False;fullHouse=0;*)
(*smallStraightK=False;smallStraight=0;*)
(*largeStraightK=False;largeStraight=0;*)
(*yahtzeeK=False;yahtzee=0;*)
(*chanceK=False;chance=0;*)
(*bonus=0;*)
(**)
(**)
(*(* Inseriamo le variabili per il blocco delle combinazioni in una lista utilizzata nel tabellone per gestire la selezione univoca dei punteggi per combinazione*)*)
(*listK:={acesK,twosK,threesK,foursK,fivesK,sixesK,threeOfAKindK,fourOfAKindK,fullHouseK,smallStraightK,largeStraightK,yahtzeeK,chanceK};*)
(**)
(*(*con 5 variabili booleane settiamo quali dadi teniamo per il punteggio e quali vogliamo rilanciare*)*)
(*dice1Lock=False;dice2Lock=False;dice3Lock=False;dice4Lock=False;dice5Lock=False;*)
(**)
(*(*instanziamo 5 variabili per salvare il valore uscito dai singoli dadi al lancio*)*)
(*dice1=0;dice2=0;dice3=0;dice4=0;dice5=0;*)
(**)
(*(* Variabile per conteggiare il numero di lanci in un turno*)*)
(*girato=0;*)
(**)
(*(* Creiamo la lista che verra poi utilizzata all'interno della tabella per mostrare le varie combinazioni con i rispettivi bottoni per la loro selezione, unendo le corrsipettive logiche per il calcolo dei punteggi in base ai dadi che abbiamoin quel turno.*)
(*Ogni riga della tabella finale \[EGrave] composta da un bottone e da un numero ma in questa lista ci sono solo i bottoni. I numeri sono inseriti pi\[UGrave] avanti nella variabile tabella. Ogni bottone \[EGrave] abilitato solo se quella combinazione non \[EGrave] ancora stata scelta in questa partita e, quando viene premuto, conferma il valore relativo e attraverso la funzione reset aggiorna il turno e sistema tutte le variabili per poter ricominciare a tirare i dadi.*)
(*La condizione nell' If controlla se i dadi sono stati tirati almeno una volta questo turno e se l'utente non ha ancora scelto una combinazione. Se questa condizione risulta falsa cliccare il bottone non ha alcun effetto: non vogliamo che gli utenti possano bloccare combinazioni "alla cieca".*)
(**)*)
(*listCombinations={Button["Aces",If[flagPunteggioSelezionato==False&&girato>0,{acesK=True,aces=checkAces[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!acesK]],Button["Twos",If[flagPunteggioSelezionato==False&&girato>0,{twosK=True,twos=checkTwos[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!twosK]],Button["Threes",If[flagPunteggioSelezionato==False&&girato>0,{threesK=True,threes=checkThrees[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!threesK]],Button["Fours",If[flagPunteggioSelezionato==False&&girato>0,{foursK=True,fours=checkFours[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!foursK]],Button["Fives",If[flagPunteggioSelezionato==False&&girato>0,{fivesK=True,fives=checkFives[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!fivesK]],Button["Sixes",If[flagPunteggioSelezionato==False&&girato>0,{sixesK=True,sixes=checkSixes[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!sixesK]],*)
(*"Totale sezione Superiore",*)
(*"Bonus Totale sezione Superiore > 63",Button["Three of a Kind",If[flagPunteggioSelezionato==False&&girato>0,{threeOfAKindK=True,threeOfAKind=checkThreeOfAKind[Sort[dices]],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!threeOfAKindK]],Button["Four of a Kind",If[flagPunteggioSelezionato==False&&girato>0,{fourOfAKindK=True,fourOfAKind=checkFourOfAKind[Sort[dices]],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!fourOfAKindK]],Button["Full House",If[flagPunteggioSelezionato==False&&girato>0,{fullHouseK=True,fullHouse=checkFullHouse[Sort[dices]],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!fullHouseK]],Button["Small Straight",If[flagPunteggioSelezionato==False&&girato>0,{smallStraightK=True,smallStraight=checkSmallStraight[Sort[dices]],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!smallStraightK]],Button["Large Straight",If[flagPunteggioSelezionato==False&&girato>0,{largeStraightK=True,largeStraight=checkLargeStraight[Sort[dices]],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!largeStraightK]],Button["Yahtzee",If[flagPunteggioSelezionato==False&&girato>0,{yahtzeeK=True,yahtzee=checkYahtzee[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!yahtzeeK]],Button["Chance",If[flagPunteggioSelezionato==False&&girato>0,{chanceK=True,chance=checkChance[dices],flagPunteggioSelezionato=True,reset},Null],Enabled->Dynamic[!chanceK]],"Totale sezione Inferiore", "Totale"};*)
(**)
(*(*instanziamo il bottone per gestire il lancio dei soli dadi liberi confrontando se non abbiamo superato il limite dei tiri per turno (3).*)
(*La condizione inziale ci permette di smettere di tirare i dadi quando sono tutti bloccati per non sprecare tiri, rendendo inutile il bottone quando questa condizione \[EGrave] falsa.*)
(*Questo bottone \[EGrave] abilitato solo quando abbiamo tirato i dadi meno di 3 volte e ci sono ancora combinazioni da riempire.*)*)
(*rollButton=Dynamic[Button["\|01f3b2 Tira i dadi! \|01f3b2",If[girato<3&&!(AllTrue[{dice1Lock,dice2Lock,dice3Lock,dice4Lock,dice5Lock},TrueQ]),{If[dice1Lock==False,dice1=RandomInteger[{1,6}]],If[dice2Lock==False,dice2=RandomInteger[{1,6}]],If[dice3Lock==False,dice3=RandomInteger[{1,6}]],If[dice4Lock==False,dice4=RandomInteger[{1,6}]],If[dice5Lock==False,dice5=RandomInteger[{1,6}]],girato++},Null],Background->White,BaseStyle->{"GenericButton",12,Bold},ImageSize->{110,40}],Enabled->Dynamic[!(girato==3||AllTrue[listK,TrueQ])]];*)
(**)
(*(*disegnamo i 5 dadi con le corrispettive logiche di gestione del valore libero o bloccato. Ogni dado \[EGrave] un bottone che cambia colore tra il rosso e il vere per significare quando il dado \[EGrave] bloccato o libero.*)*)
(**)
(*(*dado1*)*)
(*oneDice=DynamicModule[{},Button[Dynamic[If[girato>0,StringJoin[ToString[d1]," ",ToString[dice1]],"TIRA"]] Dynamic[Switch[dice1,0,"",1,imgDice1,2,imgDice2,3,imgDice3,4,imgDice4,5,imgDice5,6,imgDice6]],If[girato>0,If[d1=="Bloccato",{d1="Libero",color1=Green,dice1Lock=False},{d1="Bloccato",color1=Red,dice1Lock=True}],Null],Background->Dynamic[color1],BaseStyle->{"GenericButton",12,Bold},ImageSize->{110,40}]] ;*)
(**)
(*(*dado2*)*)
(*twoDice=DynamicModule[{},Button[Dynamic[If[girato>0,StringJoin[ToString[d2]," ",ToString[dice2]],"I"]] Dynamic[Switch[dice2,0,"",1,imgDice1,2,imgDice2,3,imgDice3,4,imgDice4,5,imgDice5,6,imgDice6]],If[girato>0,If[d2=="Bloccato",{d2="Libero",color2=Green,dice2Lock=False},{d2="Bloccato",color2=Red,dice2Lock=True}],Null],Background->Dynamic[color2],BaseStyle->{"GenericButton",12,Bold},ImageSize->{110,40}]];*)
(**)
(*(*dado3*)*)
(*threeDice=DynamicModule[{},Button[Dynamic[If[girato>0,StringJoin[ToString[d3]," ",ToString[dice3]],"DADI"]] Dynamic[Switch[dice3,0,"",1,imgDice1,2,imgDice2,3,imgDice3,4,imgDice4,5,imgDice5,6,imgDice6]],If[girato>0,If[d3=="Bloccato",{d3="Libero",color3=Green,dice3Lock=False},{d3="Bloccato",color3=Red,dice3Lock=True}],Null],Background->Dynamic[color3],BaseStyle->{"GenericButton",12,Bold},ImageSize->{110,40}]];*)
(**)
(*(*dado4*)*)
(*fourDice=DynamicModule[{},Button[Dynamic[If[girato>0,StringJoin[ToString[d4]," ",ToString[dice4]],"PER"]] Dynamic[Switch[dice4,0,"",1,imgDice1,2,imgDice2,3,imgDice3,4,imgDice4,5,imgDice5,6,imgDice6]],If[girato>0,If[d4=="Bloccato",{d4="Libero",color4=Green,dice4Lock=False},{d4="Bloccato",color4=Red,dice4Lock=True}],Null],Background->Dynamic[color4],BaseStyle->{"GenericButton",12,Bold},ImageSize->{110,40}]];*)
(**)
(*(*dado5*)*)
(*fiveDice=DynamicModule[{},Button[Dynamic[If[girato>0,StringJoin[ToString[d5]," ",ToString[dice5]],"INIZIARE"]] Dynamic[Switch[dice5,0,"",1,imgDice1,2,imgDice2,3,imgDice3,4,imgDice4,5,imgDice5,6,imgDice6]],If[girato>0,If[d5=="Bloccato",{d5="Libero",color5=Green,dice5Lock=False},{d5="Bloccato",color5=Red,dice5Lock=True}],Null],Background->Dynamic[color5],BaseStyle->{"GenericButton",12,Bold},ImageSize->{110,40}]];*)
(**)
(**)
(*(* Tabella dei punteggi con le combinazioni e il calcolo del punteggio per i dadi usciti in quel turno. Qui vengono dichiarati i punteggi abbinati ai botton ihe abbiamo descritto prima in listCombinations. Ogni valore \[EGrave] verde o rosso a seconda del suo stato: se \[EGrave] verde non \[EGrave] stato ancora bloccato e viceversa se \[EGrave] rosso. Allo stesso modo controlliamo che la combinazione non sia gi\[AGrave] stata scelta per cambiare il valore del punteggio.*)*)
(*tabella=TableForm[{{Dynamic[If[acesK==True,aces,checkAces[dices]],BaseStyle->Dynamic[If[acesK==True,Red,Green]]]},{Dynamic[If[twosK==True,twos,checkTwos[dices]],BaseStyle->Dynamic[If[twosK==True,Red,Green]]]},{Dynamic[If[threesK==True,threes,checkThrees[dices]],BaseStyle->Dynamic[If[threesK==True,Red,Green]]]},{Dynamic[If[foursK==True,fours,checkFours[dices]],BaseStyle->Dynamic[If[foursK==True,Red,Green]]]},{Dynamic[If[fivesK==True,fives,checkFives[dices]],BaseStyle->Dynamic[If[fivesK==True,Red,Green]]]},{Dynamic[If[sixesK==True,sixes,checkSixes[dices]],BaseStyle->Dynamic[If[sixesK==True,Red,Green]]]},*)
(*{Dynamic[Total[listPointSup]]},*)
(*{Dynamic[If[Total[listPointSup] > 63,bonus = 35, bonus = 0]]},*)
(*{Dynamic[If[threeOfAKindK==True,threeOfAKind,checkThreeOfAKind[Sort[dices]]],BaseStyle->Dynamic[If[threeOfAKindK==True,Red,Green]]]},{Dynamic[If[fourOfAKindK==True,fourOfAKind,checkFourOfAKind[Sort[dices]]],BaseStyle->Dynamic[If[fourOfAKindK==True,Red,Green]]]},{Dynamic[If[fullHouseK==True,fullHouse,checkFullHouse[Sort[dices]]],BaseStyle->Dynamic[If[fullHouseK==True,Red,Green]]]},{Dynamic[If[smallStraightK==True,smallStraight,checkSmallStraight[Sort[dices]]],BaseStyle->Dynamic[If[smallStraightK==True,Red,Green]]]},{Dynamic[If[largeStraightK==True,largeStraight,checkLargeStraight[Sort[dices]]],BaseStyle->Dynamic[If[largeStraightK==True,Red,Green]]]},{Dynamic[If[yahtzeeK==True,yahtzee,checkYahtzee[Sort[dices]]],BaseStyle->Dynamic[If[yahtzeeK==True,Red,Green]]]},{Dynamic[If[chanceK==True,chance,checkChance[Sort[dices]]],BaseStyle->Dynamic[If[chanceK==True,Red,Green]]]},*)
(*{Dynamic[Total[listPointInf]]},*)
(*{Dynamic[Total[listPoints]]}},TableHeadings->{listCombinations,{"Points"}}];*)
(**)
(*(* Funzione per riportare le variabili del gioco allo stato iniziale per poter giocare un nuovo turno con lo stesso utente*)*)
(*reset:={dice1=0,dice2=0,dice3=0,dice4=0,dice5=0,girato=0,dice1Lock=False,dice2Lock=False,dice3Lock=False,dice4Lock=False,dice5Lock=False,girato=0,d1="Libero",d2="Libero",d3="Libero",d4="Libero",d5="Libero",color1=Green,color2=Green,color3=Green,color4=Green,color5=Green,flagPunteggioSelezionato=False};*)
(**)
(*(* Definiamo un bottone per svuotare la tabella e riiniziare il gioco con un altro giocatore pulendo le celle di output create. Per ricominciare bisogner\[AGrave] rievaluare la cella che contiene YAHTZEE *)*)
(*cleanCellsButton=Button["Nuova partita \|01f195",{FrontEndTokenExecute["DeleteGeneratedCells"],clean,start},Method->"Queued",Background->White,BaseStyle->{"GenericButton",12,Bold},ImageSize->{150,40}];*)
(**)
(*(*Resettiamo la maggior parte delle variabili*)*)
(*clean:={acesK=False,twosK=False,threesK=False,foursK=False,fivesK=False,sixesK=False,threeOfAKindK=False,fourOfAKindK=False,fullHouseK=False,smallStraightK=False,largeStraightK=False,yahtzeeK=False,chanceK=False,aces=0,twos=0,threes=0,fours=0,fives=0,sixes=0,threeOfAKind=0,fourOfAKind=0,fullHouse=0,smallStraight=0,largeStraight=0,yahtzee=0,chance=0,reset, flagSave=True};*)
(**)
(*(*Bottone che fa ricominciare la partita senza pulire le celle eseguite fin ora.*)*)
(*restartButton=Button["Ricomincia la partita \:267b\:fe0f",clean,Background->White,BaseStyle->{"GenericButton",12,Bold},ImageSize->{150,40}];*)
(**)
(*(*Bottone che mostra gli high score: quando un punteggio viene salvato viene aggiunto al file locale chiamato punteggi.txt che viene recuperato da questo pulsante e stampato a schermo. Prima di stampare viene cancellata l'ultima cella di output perci\[OGrave] gli highscore vengono stampati una volta sola.*)*)
(*highButton=Button["Mostra High Score \|01f3ae",{NotebookDelete[NextCell[]],Print[Import[FileNameJoin[{NotebookDirectory[],"punteggi.txt"}]]]},Background->White,BaseStyle->{"GenericButton",12,Bold},ImageSize->{150,40}];*)
(**)
(*(*Bottone che apre una nuova finetra con il notebook che spiega le regole del gioco.*)*)
(*rulesButton=Button["REGOLE \|01f4d6",NotebookOpen[FileNameJoin[{NotebookDirectory[],"REGOLE.nb"}]],Background->White,BaseStyle->{"GenericButton",12,Bold},ImageSize->{150,40}];*)
(**)
(*(*Bottone per il salvataggio. Diventa cliccabile solo dopo aver giocato una partita intera, ovvero quando tutte le combinazioni sono state riempite. Quando il pulsante viene cliccato, la funzione al suo interno crea il file punteggi.txt se non esiste e aggiunge il punteggio realizzato al file. Se il file esiste gi\[AGrave] basta semplicemente aggiungere il punteggio. La funzione funzCreaStringa che fa la maggior parte del lavoro verr\[AGrave] spiegata sotto alla sua definizione.*)*)
(*saveButton=Button["Salva Punteggio \|01f4be",{ If[AllTrue[listK,TrueQ],{If[FindFile["punteggi.txt"]!="",Export[FileNameJoin[{NotebookDirectory[],"punteggi.txt"}],StringJoin["----------HIGH SCORES----------\n",StringRiffle[funzCreaStringa[prev,{ToExpression[Total[listPoints]], "-", ToString[nome]}],"\n","\t"]]],Null],If[FindFile["punteggi.txt"]!=$Failed,Null,Export[FileNameJoin[{NotebookDirectory[],"punteggi.txt"}],StringJoin["----------HIGH SCORES----------\n",ToString[Total[listPoints]],"\t","-","\t",ToString[nome],"\n"]]]},Null],flagSave = False },Enabled->Dynamic[AllTrue[listK,TrueQ] && flagSave == True],Background->White,BaseStyle->{"GenericButton",12,Bold},ImageSize->{150,40}];*)
(**)
(*(*bottone che permette di chiudere il gioco, cancellando tutto cio\[OGrave] che \[EGrave] stato stampato*)*)
(*closeButton=Button["Termina il gioco",{FrontEndTokenExecute["DeleteGeneratedCells"],clean},Background->Red,BaseStyle->{"GenericButton",12,Bold},ImageSize->{150,40}];*)
(**)
(*(*Da qui alla fine del modulo ci sono dei Print che ci permettono di creare il tabellone di gioco chiamando semplicemente YAHTZEE dal notebook principale.*)*)
(*Print[Text[Style[StringJoin["\|01f468\:200d\|01f4bb Nome Giocatore: ",utente," \|01f468\:200d\|01f4bb"],FontSize->30]]];*)
(**)
(*(*Per dare l'apparenza di un allineamento centrato mettiamo dei bottoni invisibili prima del bottone per tirare i dadi.*)*)
(*Print["\n",Button["",Null,Appearance->None,ImageSize->{125,40},Enabled->False],"\t",Button["",Null,Appearance->None,ImageSize->{95,40},Enabled->False],"\t",rollButton];*)
(**)
(*Print[oneDice,"\t",twoDice,"\t",threeDice,"\t",fourDice,"\t",fiveDice];*)
(**)
(*Print[tabella];*)
(**)
(*Print[saveButton];*)
(**)
(*Print["\n",cleanCellsButton,"\t",restartButton,"\t",highButton,"\t",rulesButton,"\t",closeButton];*)
(*]; *)
(**)
(*(*Permette di inizializzare una nuova partita*)*)
(*start:=Module[{},NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"START_GAME.nb"}]]];*)
(**)
(**)
(**)
(*(*utente restituisce il nome che abiamo preso in input. Per via del funzionamento della funzione di sort che usiamo in funzCreaStringa gli spazi non sono permessi quindi vengono eliminati prima di ritornare l'input. Se l'utente esce dalla schermata di input o non inserisce un nome gli viene assegnato il nome "Sconosciuto" dal sistema.*)*)
(**)
(**)
(*(*Le funzioni check servono per controllare quanti punti un particolare set di dadi fa in una determinata categoria. Ci sono 14 funzioni check: 13 per le combinazione e una per il bonus(la funzione per il bonus \[EGrave] scritta direttamente nella tabella). Siccome le prime sei sono simili tra loro spieghiamo solo la prima. Tutte le funzioni restituiscono il numero di punti adatto secondo le regole di yahtzee oppure 0 se il pattern non viene riconosciuto.*)*)
(*(*checkAces controlla quanti 1 ci sono nel set di dadi passato come parametro e restituisce la somma di questi 1*)*)
(*checkAces[dices_]:=Module[{sum},sum=0;If[#==1,sum=sum+1,Null]&/@dices;Return[sum];];*)
(**)
(*checkTwos[dices_]:=Module[{sum},sum=0;If[#==2,sum=sum+2,Null]&/@dices;Return[sum];];*)
(**)
(*checkThrees[dices_]:=Module[{sum},sum=0;If[#==3,sum=sum+3,Null]&/@dices;Return[sum];];*)
(**)
(*checkFours[dices_]:=Module[{sum},sum=0;If[#==4,sum=sum+4,Null]&/@dices;Return[sum];];*)
(**)
(*checkFives[dices_]:=Module[{sum},sum=0;If[#==5,sum=sum+5,Null]&/@dices;Return[sum];];*)
(**)
(*checkSixes[dices_]:=Module[{sum},sum=0;If[#==6,sum=sum+6,Null]&/@dices;Return[sum]];*)
(**)
(*(*Da checkThreeOfAKind le funzioni si affidano a dei pattern che si basano sull'assunzione che la lista in input sia ordinata in ordine crescente. Ordinare i dadi per noi \[EGrave] semplice usando la funzione Sort (questo viene fatto quando la funzione viene chiamata) e ci permette di usare molti meno pattern per controllare se un set di dadi fa punti per queste combinazioni. I patter per questa funzione sono tre: visto che controlliamo 3 dadi con lo stesso numero, i restanti due dadi possono essere o entrambi minori, o uno maggiore e uno minore del valore comune ai tre oppure entrambi maggiori. In tutti questi casi il pattern ritorna vero e la funzione restituisce la somma di tutti i dadi del set.*)*)
(*checkThreeOfAKind[dices_]:=Module[{sum},sum=0;If[MatchQ[dices,{__,__,x_,x_,x_}|{__,x_,x_,x_,__}|{x_,x_,x_,__,__}],sum=Total[dices],sum=0];Return[sum];];*)
(**)
(*(*checkFourOfAKind \[EGrave] simile alla precedente ma qui controlliamo che 4 dadi siano uguali, questo vuol dire che il restante dado \[EGrave] o minore o maggiore degli altri risultando in 2 pattern e basta.*)*)
(*checkFourOfAKind[dices_]:=Module[{sum},sum=0;If[MatchQ[dices,{__,x_,x_,x_,x_}|{x_,x_,x_,x_,__}],sum=Total[dices],sum=0];*)
(*Return[sum];];*)
(**)
(*(*checkFullHouse ha lo stesso numero di pattern di checkThreeOfAKind visto che cerchiamo un tris e una coppia. La coppia sar\[AGrave] di valori minori o maggiori dei valori del tris. la condizione /;x!=y fa in modo che con cinque dadi uguali non si attivi il full house. Incidentalmente, questo previene anche il caso in cui full house segna dei punti anche quando i dadi non sono ancora stati tirati.*)*)
(*checkFullHouse[dices_]:=Module[{sum},sum=0;*)
(*If[MatchQ[dices,({y_,y_,x_,x_,x_}|{x_,x_,x_,y_,y_})/;x!=y],sum=25,sum=0];*)
(*Return[sum];];*)
(**)
(*(*checkSmallStraight funziona un po' diversamente: ci sono solo 3 possibili combinazioni che risultano in uno small straight: 1,2,3,4 | 2,3,4,5 | 3,4,5,6 ma il quinto dado pu\[OGrave] essere uno qualunque tra 1 e 6. Usando gli OrderlessPattern possiamo ignorare l'ordine e concentrarci sul contenuto.*)*)
(*checkSmallStraight[dices_]:=Module[{sum},sum=0;*)
(*If[MatchQ[dices,{OrderlessPatternSequence[1,2,3,4,__]}|{OrderlessPatternSequence[2,3,4,5,__]}|{OrderlessPatternSequence[3,4,5,6,__]}],sum=30,sum=0];Return[sum]];*)
(**)
(*(*checkLargeStraight: ordinando i dadi ci sono solo due opzioni, segnate qui sotto. Basta controllarle e assegnarvi i valori adatti*)*)
(*checkLargeStraight[dices_]:=Module[{sum},If[MatchQ[dices,{1,2,3,4,5}|{2,3,4,5,6}],sum=40,sum=0];Return[sum]];*)
(**)
(*(*Yahtzee si fa quando tutti e 5 i dadi hanno lo stesso valore. Ci serve solo un semplice pattern*)*)
(*checkYahtzee[dices_]:=Module[{sum},If[MatchQ[dices,{x_,x_,x_,x_,x_}&&dice1!=0],sum=50,sum=0];Return[sum];];*)
(**)
(*(*chance \[EGrave] sempre disponibile e ritorna sempre la somma dei dadi*)*)
(*checkChance[dices_]:=Module[{},Return[Total[dices]];];*)
(**)
(*(*questa funzione prende come parametri una lista di punteggi ordinati e un punteggio nella forma {punteggio(int), - ,nome(str)} e restituisce una lista ordinata di liste che rappresentano un punteggio compresa quella in input*)*)
(*funzCreaStringa[listPar_,punt_] := Module[{},value = listPar; Return[ReverseSort[AppendTo[value,punt]]];];*)
(**)
(*(*prev crea una lista di punteggi in questo modo: apre il file punteggi.txt e fa un import del contenuto riga per riga in una lista, StringSplit trasforma queste righe in liste di parole, di queste liste di parole droppiamo la prima che sar\[AGrave] sempre l'intestazione del file "----------HIGH SCORE----------", resta una lsita di liste di punteggi, ogni primo valore viene trasformato in numero perch\[EGrave] \[EGrave] il punteggio, a questo punto possiamo ordinare la lista di liste risultante in ordine decrescente. *)*)
(*prev := Module[{},Return[ReverseSort[MapAt[ToExpression,{All,1}]@Drop[StringSplit[Import[FileNameJoin[{NotebookDirectory[],"punteggi.txt"}],{"Text","Lines"}]],1]]]];*)
(**)
(*(*nome =InputString["Dicci il tuo nome per cominciare! Gli spazi tra le parole saranno eliminati!"];*)
(*utente:=Module[{},If[ToString[nome] == "$Canceled" || ToString[nome] == "" || StringMatchQ[ToString[nome],Whitespace] ,nome = "Sconosciuto",nome = StringRiffle[StringSplit[nome],""]]; Return[nome];];*)*)
(**)
(*utente:=Module[{},nome=InputString["Dicci il tuo nome per cominciare! Gli spazi tra le parole saranno eliminati!"];If[ToString[nome]=="$Canceled"||ToString[nome]==""||StringMatchQ[ToString[nome],Whitespace],nome="Sconosciuto",nome=StringRiffle[StringSplit[nome],""]];Return[nome];];*)
(*(*seme viene chiamato quando impostiamo il seed come prima istruzione di YAHTZEE. Se in input abbiamo qualcosa di valido (una stringa o un intero per esempio), viene usato quello come seme, altrimenti viene usato il tempo in millisecondi dal 1 Gennaio 1970 grazie a UnixTime[] *)*)
(*seme := Module[{ret},seed=InputString["Se vuoi usare un seme per il generatore casuale inseriscilo qua. In caso contrario lascia vuota la casella o chiudila con la x in alto a destra."];*)
(*If[ToString[seed]=="$Canceled"||ToString[seed]==""||StringMatchQ[ToString[seed],Whitespace],ret = UnixTime[],ret = seed];Return[ret];];*)
(*End[]*)
(**)
(*EndPackage[]*)
